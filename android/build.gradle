import java.nio.file.Files
import java.nio.file.Paths

group = "com.example.flutter_ort_plugin"
version = "1.0"

apply plugin: "com.android.library"


// --- ONNX RUNTIME DOWNLOAD CONFIGURATION ---
def ortConfigs = [
    "standard": [
        "url": "https://github.com/certainlyWrong/flutter_ort_plugin/releases/download/v1.0.0/jniLibs.zip",
        "label": "STANDARD"
    ],
    "providers": [
        "url": "https://github.com/certainlyWrong/flutter_ort_plugin/releases/download/v1.0.0/jniLibs_providers.zip",
        "label": "WITH_PROVIDERS"
    ]
]

/**
 * Determine strategy: 
 * Check for project property ORT_STRATEGY (e.g., ./gradlew -PORT_STRATEGY=providers)
 * Default to "standard" if not specified.
 */
def selectedStrategy = project.hasProperty("ORT_STRATEGY") ? project.getProperty("ORT_STRATEGY") : "standard"
def config = ortConfigs[selectedStrategy] ?: ortConfigs["standard"]

def downloadDest = "${project.buildDir}/onnx_libs_${selectedStrategy}.zip"
def jniLibsDir = "${project.projectDir}/src/main/jniLibs"

task downloadOnnxRuntimeCustom(type: Task) {
    description = "Downloads and extracts the required ONNX Runtime binaries based on the selected strategy."
    
    doFirst {
        // Marker file to track the current strategy and prevent redundant downloads
        def markerFile = new File(jniLibsDir, "strategy_${selectedStrategy}.marker")
        
        if (!markerFile.exists()) {
            println "üöÄ [flutter_ort_plugin] Starting download: ONNX Runtime [Strategy: ${config.label}]"
            println "üîó [flutter_ort_plugin] Source: ${config.url}"
            
            // Clean up old binaries to prevent conflicts between different strategies
            delete jniLibsDir
            if (!project.buildDir.exists()) mkdir project.buildDir
            
            try {
                ant.get(src: config.url, dest: downloadDest, skipexisting: false)
                
                println "üì¶ [flutter_ort_plugin] Extracting binaries to jniLibs folder..."
                copy {
                    from zipTree(downloadDest)
                    into "${project.projectDir}/src/main/"
                }
                
                // Create strategy marker
                markerFile.text = "strategy=${selectedStrategy}\nlabel=${config.label}\nbuild_date=${new Date().toString()}"
                
                println "‚úÖ [flutter_ort_plugin] Success: ${config.label} binaries are ready."
            } catch (Exception e) {
                throw GradleException("‚ùå [flutter_ort_plugin] Failed to download ONNX Runtime binaries. Please check your internet connection. Error: ${e.message}")
            }
        } else {
            println "‚ÑπÔ∏è [flutter_ort_plugin] ONNX Runtime ${config.label} is already installed. Skipping download."
        }
    }
}

// Ensure the download task is executed before the native build process
project.afterEvaluate {
    if (tasks.findByName("preBuild")) {
        tasks.named("preBuild").configure {
            dependsOn downloadOnnxRuntimeCustom
        }
    }
}

android {
    namespace = "com.example.flutter_ort_plugin"
    compileSdk = 36
    ndkVersion = "27.0.12077973"

    externalNativeBuild {
        cmake {
            path = "../src/CMakeLists.txt"
        }
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    defaultConfig {
        minSdk = 24
        
        // Importante para o CMake encontrar a lib que voc√™ baixou
        externalNativeBuild {
            cmake {
                arguments "-DANDROID_STL=c++_shared"
            }
        }
    }

    sourceSets {
        main {
            jniLibs.srcDirs = ['src/main/jniLibs']
        }
    }
}